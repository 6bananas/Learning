> 无法定义 C++ 是什么，更多的感觉是在 C 的基础上扩展，基本的语法跟 C 大差不差。
>
> C/C++ 很熟悉也很熟练啊，大学计算机的教学语言，广大计算机学生的第一门编程语言。打过算法比赛，大学刷算法题的标准语言，学习其它语言的对比基石，也写过嵌入式。
>
> 太熟悉了，所以就写得很简单了。

# C基础

- 标识符由数字、字母、下划线组成，第一个字符必须是字母或下划线。

- 保留字，标识符的一种，又称关键字。

- 三种控制结构：顺序、分支、循环。

- `#include <stdio.h>` 这类是编译预处理命令。

- 运算符 % 为 模（求余），只能对整型数据使用。

- 常用数学函数：

  - sqrt(x) - 平方根
  - fabs(x) - 绝对值
  - pow(x, n) - 幂
  - exp(x) - e 的指数
  - round(x) - 四舍五入
  - log(x) - 求 lnx

- %4d - 输出占四位，右对齐；%-4d - 输出占四位，左对齐；%6.1f - 输出占六位，一位小数，右对齐；%02d - 输出占两位，右对齐，不足位左补零。

- %2d - 读入两位。

- 循环控制变量，简称循环变量。

- n>12 时，n! 超出 int 范围。

- getchar() - 读入一个字符；putchar(ch) - 输出字符 ch（不换行）。

- 闰年：能被 4 整除但不能被100 整除，或能被 400 整除。

- `case 1+2:` 、`case 'a'+'b':` 等 `case 表达式:` 均可，保证 case 后面必须跟单体即可。

- 级联 case ：` case 0: case 1: case 2:` 。

- continue 只能用于循环。

- 解方程模板：多级循环。

- 函数传参时，顺序为从右到左。

- 函数类型默认定义为 int 。

- 局部变量与全局变量同名时，局部变量起作用。

- 局部变量又称自动变量，自动变量定义形式是 `auto 类型名 变量表;` ，auto 可省。

- 数据存储区的构成：

  -  静态存储区：存放全局变量、静态局部变量
  - 动态存储区：main 函数的变量、自定义函数的变量

  数组大小 >=10<sup>6</sup> 时，应把其定义到 main 函数外，因为动态存储区相对较小。

- 静态变量，又称静态局部变量，定义格式 `static 类型名 变量表;` 。它的生存周期会持续到程序结束，当被调用时才会激活，值为上一次调用后的值。

- 整型变量如未赋值，系统自动赋初值 0 。

- 每个字符在内存中占一个字节，int 占两个字节，double 占八个字节。

- 整数后缀：l 或 L - long、u 或 U - unsigned、lu 或 LU - unsigned long 。

- float 精度 7\~8 位，double 精度 15\~16 位。

- 格式控制说明：

  | 数据类型      | 十进制 | 八进制 | 十六进制 |
  | ------------- | ------ | ------ | -------- |
  | int           | %d     | %o     | %x       |
  | long          | %ld    | %lo    | %lx      |
  | unsigned      | %u     | %o     | %x       |
  | unsigned long | %lu    | %lo    | %lx      |

  x 为小写，则 a\~f 也要小写；X 为大写，则 A\~F 要大写。

  实数：

  - printf：%f - 小数形式；%e - 指数形式
  - scanf：float - %f %e；double - %lf %le

- 实数类型转换为整数，直接掐尾，如 2.56→2 。

- 优先级：! > 算术 > 关系 > && > || > 赋值。关系运算符：> == < 这些。

- sizeof(x)：返回 x 的字节长度。

- 数组名是一个地址常量，存放数组内存空间的首地址。

  数组名其实相当于一个指针变量，一维、二维相当于一级、二级。

  对于二维数组，a[0] 或 a 指向第一行的首地址。

- 静态数组（如 `static int a[5];` ）如果没有初始化，系统自动全赋 0 ；只赋部分，余下也自动全赋 0 。非静态数组如果没有初始化，系统自动赋随机值；只赋部分，余下自动全赋 0 。

- 字符数组还可以这样赋值：

  - `char s[6]={"Happy"};`
  - `char s[6]="Happy";`

  这样赋值，则 `'\0`' 会自动加到末尾。如果是单个单个赋值，则需要手动加上 `'\0'` 。

- 字符串清空：`<stdio.h>` 库函数 `memset(s, 0, sizeof(s))` 。

- 不同类型的指针变量所占内存空间的大小都是相同的。

- `int *p=0;` 定义了一个空指针，此处 0 是 ASCII 字符 NULL 。

- 函数形参中，如果是接收数组的起始地址，则需要用如 `int a[]` 。

- 如果 p 和 q 是指向数组元素的两个指针，那么 p-q 产生一个 int 型的值，表示在 p 和 q 之间数组元素个数。

- strcpy(s1, s2 )：字符串 s2 替换 s1，返回 s1 的指针。

  ```c
  char s1[20], s2[] = "Hello, World!";
  strcpy(s1, s2);
  printf("%s\n", s1);  // 输出: Hello, World!
  ```

- strcat(s1, s2)：字符串连接，s1 必须有足够的空间来容纳追加的内容，返回 s1 的指针。

  ```c
  char s1[30] = "Hello", s2[] = " World!";
  strcat(s1, s2);
  printf("%s\n", s1);  // 输出: Hello World!
  ```

- strcmp(s1, s2)：字符串比较，返回一个整数。

- strlen(s)：字符串长度计算，返回一个整数。

- `char *s; scanf("%s", s);` 或 `char *s=NULL; scanf("%s", s);` ，字符串都是读不进 s 里的，因为指针 s 还没有指向一个确定的地址空间，所以它装不了东西。

- scanf 遇空格或回车结束，不读入空格或回车。如果读入的是字符串，自动将 `'\0'` 送入。

- printf 输出字符串时，遇 `'\0'` 停止，不会自动输出回车。

- gets(s) 读入一个字符串，s 是数组名，遇到回车结束，不读入回车，自动将 `'\0'` 送入，读入的字符串允许带空格。

- puts(x) 输出一个字符串，x 可以是字符串常量、数组变量或指针，遇到 `'\0'` 停止，自动输出回车。

- 动态分配函数：

  - malloc() - `p=(int *)malloc(n*sizeof(int))` 。分配成功返回指向起始地址的指针，分配失败返回 NULL 。 
  - calloc() - `p=(int *)calloc(n*sizeof(int))` 。分配成功返回指向起始地址的指针，并全部初始化为 0 ，分配失败返回 NULL 。初始化值 double/float - 0.0，char - \0（ASCII 码 0）。

- free(p) - 释放 p 所指地址空间。

- 构造数据类型（派生数据类型）：数组、指针、结构体。

- `#define 宏名 宏定义字符串` 属于预处理命令，作用为在编译时进行宏替换。如果宏定义字符串一行写不下，可以在该行末尾加 `\` ，然后另起一行写。

  宏定义不可在函数中（包括 main ）定义。

  宏定义贯穿整个文件，可使用 `#undef 宏名` 结束宏定义。

- `#include <file>` 表示包含库文件，`#include "file"` 表示包含自定义文件。包含 `"file"` 时，系统先检查当前工作目录是否包含该文件，没有则再到库中检查。 

- 指针函数：`int *function(){}` 。

- 函数指针：`int (*funcptr)(int, int);` ，定义一个指向参数列表为 (int, int) 的函数指针。

  使用：

  1. 定义函数 func(int, int)
  2. funcptr = func
  3. 调用 (*funcptr)(3, 5) 相当于 func(3, 5) 。

- 文件指针：`FILE *fp;` ，FILE 是在 stdio.h 中用 typedef 命名的一个包含文件信息的结构体。

  fp 会自动后移位置，因为 fp++ 后 fp 指向的是下一个文件对应的 fp ，所以系统不需要你对 fp 手动移位。

- fopen("filename", "打开方式")：返回文件指针。

- fclose(fp)：返回一个整数，0 表示正常关闭。

- fgetc(fp)：读取单个字符。

- fputc(ch, fp)：写入单个字符，失败返回 EOF 。EOF 是符号常量，值为 -1，定义在 stdio.h 。

- feof(fp)：检查 fp 是否到了文件末尾。

- fgets(s, n, fp)：s - 字符数组名或字符指针，n - 读入字符个数。最多读取 n-1 个字符。当达到指定个数，或读取到换行符（该换行符也读入），或达到 EOF （EOF 不会读入）时，结束读取，自动送入 `'\0'` 。成功返回读取字符串，失败返回空指针。

- fscanf()、fprintf() 同 scanf()、printf() ，只需要加上 fp 即可，如 `fscanf(fp, "%s", s);` 。

- fread(buffer, size, count, fp)、fwrite(buffer, size, count, fp)：多用于二进制文件。buffer - 指针，size - 每次操作的字节数，count - 操作次数。

# 结构体

## 定义

### 法一

```cpp
struct name{
    xxx;
};
```

name 就相当于 int 这些。此时，定义结构体变量、数组、指针的方法：

- 直接在定义结构体时，} 与 ; 间写上结构体变量名/数组名/指针名。

- 需要时再定义：`name xxx;` 。也可以使用 C 的定义方法 `struct name xxx;` 。

  > 虽然 C++ 中直接 `name xxx;` 是合法的，但更推荐和 C 一样统一使用 typedef 起别名。

### 法二

```cpp
struct{
    xxx;
};
```

此时，定义结构体变量只能使用法一中所述的第一种方法，并且不支持循环定义。**（不推荐）**

### 循环定义

```cpp
struct name{
    name xxx;	// 不推荐这样定义
    name *xxx;
};
```

### 与C的区别

C 中 struct name 才相当于 int 这些。如果使用 typedef ，即：

```c
typedef struct name{
    xxx;
} name;
```

此时 name 也相当于 int 这些了。但就算用了 typedef ，在循环定义时还是要 struct name xxx 。

### 注意

请在使用 typedef 为 struct 起别名时，带上 struct 的名字。即使用 `typedef struct name{} name;` 而不要 `typedef struct{} name;` 。

同时，注意内存管理，在循环定义的时候指定为指针类型。

在 C 语言中，C++ 也是一样，循环定义：

```c
typedef struct {
    int a;
    struct name b;
} name;
```

是合法的,，但是有一个潜在的问题：你使用了 `struct name` ，而在当前的代码上下文中并没有定义 `name` 结构体本身。所以，编译器会认为你在定义 `struct name` 时，它是一个递归结构体（ `name`  类型的结构体内部包含一个 `name` 类型的成员）。这种做法是有效的，但你必须首先声明 `struct name` 。

正确的写法：

递归结构体：要让结构体 `name` 包含一个 `struct name` 类型的成员，可以通过先声明一个 `struct name` 来确保它是有效的。你可以在结构体定义中嵌套引用自身类型的结构体指针。

```c
typedef struct name {
    int a;
    struct name* b;  // 使用指针来引用结构体自身
} name;
```

或者，如果你想让 `b` 是 `name` 类型的另一个实例，而不是指针，则需要显式地指定结构体的名称：

```c
typedef struct name {
    int a;
    struct name b;  // 递归成员：这里 b 是一个 name 类型的实例
} name;
```

递归结构体和内存管理：

- 在递归结构体（即结构体中包含自身类型的成员）中，常常使用指针来避免内存大小无限增长。例如，如果 `b` 是 `struct name*` 类型的指针，就可以形成一个递归的数据结构（如链表、树等）。
- 如果你直接使用 `struct name b;` 而不使用指针，则每个 `name` 实例将包含一个完整的 `name` 实例，这会导致无限递归，并使得编译器无法分配足够的内存空间。

总之，递归结构体是允许的，但通常使用指针来避免内存无限增长。如果要定义一个包含自身类型的成员，通常使用指向该类型的指针（如 `struct name* b;`），而不是直接嵌套结构体实例。

## 初始化

```c++
// C/C++
struct student stu={xxx, xxx};
// C++
student stu={xxx, xxx};
```

## 访问

- 结构体变量访问成员变量：name.xxx 。
- 结构体数组访问成员变量：name[i].xxx 。
- 结构体指针访问成员变量：name->xxx 。也可用 `.` 如 (*p).num 。但 *p.num 等价于 *(p.num) ，优先级问题。

## 构造函数

```cpp
struct student{
    int id;
    char gender;
    student(){ //函数名要与结构体名一致
        id = xxx;
        gender = xxx;
    }
};

或
    
struct student{
    int id;
    int gender;
    student(){} //默认的构造函数，建议带上
    //构造函数的重载
    student(int _id){
        id = _id;
    }
    student(int _id, char _gender){
        id = _id;
        gender = _gender;
    }
    //简化写法
    student(int _id, char _gender): id(_id), gender(_gender){}
};

// 初始化：
student stu=student(123, "male");
```

# I/O

cout 输出 double 时，默认输出六位有效数字。所以：

```cpp
double n = 6997243;
cout << n;
//输出6.99724e+06
```

# typedef和define

typedef 和 define 都是替一个对象取一个别名，以此增强程序的可读性。

define 是预处理指令，在预处理时进行简单的字符串替换，不作正确性检查，只有在编译已被预处理后的源程序时才会发现可能的错误并报错。

typedef 是关键字，在编译时处理，用于给一个已经存在的类型一个别名。注意不能在一个函数定义里面使用 typedef 。

显然，define 的”替换“功能更强大。typedef 只能给已存在的类型取别名，define 在此基础上还可以像 `#define PI 3.14159` 这样”替换“。用的话，替换数据类型建议用 typedef ，define 更适合替换常量这些。

# C/C++数据类型

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |
| float          | 4 字节      | 1.2E-38 到 3.4E+38（6位有效位）                      |
| double         | 8 字节      | 2.3E-308 到 1.7E+308（15位有效位）                   |
| long double    | 16 字节     | 3.4E-4932 到 1.1E+4932（19位有效位）                 |

在 C/C++ 等编程语言中，`int` 的字节数（通常是 2 字节或 4 字节）并不是由 C 或 C++ 语言标准固定的，而是根据不同的系统、编译器以及处理器架构的规范而有所不同。

不同平台（如 x86、x64、ARM、MIPS 等）有不同的对 `int` 类型大小的定义。**大多数现代平台（例如基于 x86 和 x64 架构的计算机）使用 4 字节来存储 `int` 类型数据**，而一些早期平台或嵌入式系统可能会使用 2 字节。

不同的编译器（如 GCC、MSVC、Clang 等）可能会根据目标架构的要求来定义 `int` 的大小。

常见的 `int` 大小情况：

- 32 位系统（如 x86）：通常 `int` 是 4 字节。
- 64 位系统（如 x64）：通常 `int` 是 4 字节。
- 16 位系统（如早期的 16 位处理器 80286）：可能 `int` 是 2 字节。
- 嵌入式系统：一些嵌入式平台或特殊硬件架构上，`int` 可能是 2 字节。

要明确区分在当前平台上 `int` 的字节数，可以通过以下方式：

1. 使用 `sizeof(int)` 。

2. 使用预定义宏和标准。虽然 `sizeof(int)` 可以帮助你确定大小，但也可以通过一些预定义的宏来获取平台和编译器信息：
   - `__SIZEOF_INT__`：GCC 和 Clang 编译器提供的预定义宏，用来表示 `int` 的字节大小。
   - `INT_MAX` 和 `INT_MIN`：通过这些宏常量，你可以获取 `int` 类型的取值范围。

若需要跨平台开发并依赖于数据大小，建议使用标准库中的 `int32_t`（4 字节 int） 或 `int16_t`（2 字节） 等类型，这些类型在 `<stdint.h>` 中定义，保证跨平台的一致性。
